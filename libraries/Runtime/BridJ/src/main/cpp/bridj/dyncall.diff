Index: dyncall/dyncallback/dyncall_callback_x86_gas.S
===================================================================
--- dyncall/dyncallback/dyncall_callback_x86_gas.S	(révision 813)
+++ dyncall/dyncallback/dyncall_callback_x86_gas.S	(copie de travail)
@@ -95,21 +95,25 @@
 
 	// handle return value
 
+	cmp %al, 'v'
+	je .return_void
 	cmp %al, 'd'
 	je .return_f64
 	cmp %al, 'f'
 	je .return_f32
 	cmp %al, 'l'
 	je .return_i64
-	cmp %al, 'i'
-	je .return_i32
-	ret
+	cmp %al, 'L'
+	je .return_i64_
+	
+	// All int cases <= 32 bits (+ pointer & string cases) fall in the 32 bits int case
 
 .return_i32:
 	mov  %eax, [%edx]
 	ret
 
 .return_i64:
+.return_i64_:
 	mov  %eax, [%edx]
 	mov  %edx, [%edx+4]
 	ret
@@ -121,3 +125,6 @@
 .return_f64:
 	fld qword ptr [%edx]
 	ret
+
+.return_void:
+  	ret
Index: dyncall/dyncallback/dyncall_callback_x86_masm.asm
===================================================================
--- dyncall/dyncallback/dyncall_callback_x86_masm.asm	(révision 813)
+++ dyncall/dyncallback/dyncall_callback_x86_masm.asm	(copie de travail)
@@ -93,16 +93,19 @@
   mov  ebp, [ebp]                    ; EBP = parent frame
 
   ; handle return value
+  
+  cmp al, 'v'
+  je return_void
   cmp al, 'd'
   je return_f64
   cmp al, 'f'
   je return_f32
   cmp al, 'l'
   je return_i64
-  cmp al, 'i'
-  je return_i32
-  ret
-
+  cmp al, 'L'
+  je return_i64
+  ; All int cases <= 32 bits (+ pointer & string cases) fall in the 32 bits int case
+  
 return_i32:
   mov  eax, [edx]
   ret
@@ -120,6 +123,9 @@
   fld qword ptr [edx]
   ret
 
+return_void:
+  ret
+
 _dcCallbackThunkEntry ENDP
 
 END
Index: dyncall/dyncallback/dyncall_callback_x86_apple.s
===================================================================
--- dyncall/dyncallback/dyncall_callback_x86_apple.s	(révision 813)
+++ dyncall/dyncallback/dyncall_callback_x86_apple.s	(copie de travail)
@@ -44,10 +44,12 @@
 frame_DCArgs       = -24
 frame_DCValue      = -32
 
+ASCII_L = 76
 ASCII_l = 108
 ASCII_d	= 100
 ASCII_f = 102
 ASCII_i = 105
+ASCII_v = 118
 
 _dcCallbackThunkEntry:
 	push %ebp
@@ -96,21 +98,25 @@
 
 	// handle return value
 
+	cmp %al, ASCII_v
+	je .return_void
 	cmp %al, ASCII_d
 	je .return_f64
 	cmp %al, ASCII_f
 	je .return_f32
 	cmp %al, ASCII_l
 	je .return_i64
-	cmp %al, ASCII_i
-	je .return_i32
-	ret
+	cmp %al, ASCII_L
+	je .return_i64_
+	
+	// All int cases <= 32 bits (+ pointer & string cases) fall in the 32 bits int case	
 
 .return_i32:
 	mov  %eax, [%edx]
 	ret
 
 .return_i64:
+.return_i64_:
 	mov  %eax, [%edx]
 	mov  %edx, [%edx+4]
 	ret
@@ -122,3 +128,6 @@
 .return_f64:
 	fld qword ptr [%edx]
 	ret
+
+.return_void:
+	ret
Index: dyncall/test/plain/test_main.c
===================================================================
--- dyncall/test/plain/test_main.c	(révision 813)
+++ dyncall/test/plain/test_main.c	(copie de travail)
@@ -284,6 +284,7 @@
 DC_DEFINE_TEST_FUNC_END
 #endif
 
+int testCallStructs();
 
 int main(int argc, char* argv[])
 {
@@ -293,6 +294,12 @@
   b = b && testCallC();
   printf("C:%d\n",b);
 
+  b = b && testStructSizes();
+  printf("Struct Sizes:%d\n",b);
+
+  b = b && testCallStructs();
+  printf("Call Structs:%d\n",b);
+
 #if defined(DC__OS_Win32)
   
   b = b && testCallStd();
Index: dyncall/test/plain/GNUmakefile
===================================================================
--- dyncall/test/plain/GNUmakefile	(révision 813)
+++ dyncall/test/plain/GNUmakefile	(copie de travail)
@@ -24,7 +24,7 @@
 include $(TOP)/buildsys/gmake/prolog.gmake
 
 TARGET_APP	= plain
-UNITS		= test_main
+UNITS		= test_main test_structs
 CPPFLAGS	+= -I$(TOP)/dyncall
 LINK_DIRS	= $(TOP)/dyncall/$(BUILD_DIR)
 LINK_LIBS       = dyncall_s
Index: dyncall/dyncall/dyncall_callvm_mips_n64.c
===================================================================
--- dyncall/dyncall/dyncall_callvm_mips_n64.c	(révision 813)
+++ dyncall/dyncall/dyncall_callvm_mips_n64.c	(copie de travail)
@@ -190,6 +190,7 @@
 , &dc_callvm_argFloat_mips_n64
 , &dc_callvm_argDouble_mips_n64
 , &dc_callvm_argPointer_mips_n64
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_mips_n64
 , (DCboolvmfunc*)       &dc_callvm_call_mips_n64
 , (DCcharvmfunc*)       &dc_callvm_call_mips_n64
@@ -200,6 +201,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_mips_n64
 , (DCdoublevmfunc*)     &dc_callvm_call_mips_n64
 , (DCpointervmfunc*)    &dc_callvm_call_mips_n64
+, NULL // argStruct
 };
 
 DCCallVM_vt gVT_mips_n64_ellipsis =
Index: dyncall/dyncall/dyncall_vector.c
===================================================================
--- dyncall/dyncall/dyncall_vector.c	(révision 813)
+++ dyncall/dyncall/dyncall_vector.c	(copie de travail)
@@ -22,14 +22,31 @@
 
 #include "dyncall_vector.h"
 #include <string.h>
+//void memcpy(void*, const void*, size_t);
 
 void dcVecAppend(DCVecHead* pHead, const void* pData, size_t size)
 {
-  if (pHead->mSize+size <= pHead->mTotal) 
+	size_t newSize = pHead->mSize + size;
+  if (newSize <= pHead->mTotal) 
   {
-    void* dst = (char*)dcVecData(pHead) + pHead->mSize;
-    memcpy(dst, pData, size); /* @@@ heavy for small types. */
-    pHead->mSize += size;
+  	void* dst = (char*)dcVecData(pHead) + pHead->mSize;
+  	switch (size) {
+  	case 1:
+  		*(char*)dst = *(const char*)pData;
+  		break;
+  	case 2:
+  		*(short*)dst = *(const short*)pData;
+  		break;
+  	case 4:
+  		*(int*)dst = *(const int*)pData;
+  		break;
+  	case 8:
+  		*(long long*)dst = *(const long long*)pData;
+  		break;
+  	default:
+  		memcpy(dst, pData, size); /* @@@ heavy for small types. */
+  	}
+    pHead->mSize = newSize;
   } 
 }
 
Index: dyncall/dyncall/dyncall_callvm_mips_eabi.c
===================================================================
--- dyncall/dyncall/dyncall_callvm_mips_eabi.c	(révision 813)
+++ dyncall/dyncall/dyncall_callvm_mips_eabi.c	(copie de travail)
@@ -152,6 +152,7 @@
 , &dc_callvm_argFloat_mips_eabi
 , &dc_callvm_argDouble_mips_eabi
 , &dc_callvm_argPointer_mips_eabi
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_mips_eabi
 , (DCboolvmfunc*)       &dc_callvm_call_mips_eabi
 , (DCcharvmfunc*)       &dc_callvm_call_mips_eabi
@@ -162,6 +163,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_mips_eabi
 , (DCdoublevmfunc*)     &dc_callvm_call_mips_eabi
 , (DCpointervmfunc*)    &dc_callvm_call_mips_eabi
+, NULL // argStruct
 };
 
 DCCallVM* dcNewCallVM_mips_eabi(DCsize size) 
Index: dyncall/dyncall/GNUmakefile
===================================================================
--- dyncall/dyncall/GNUmakefile	(révision 813)
+++ dyncall/dyncall/GNUmakefile	(copie de travail)
@@ -37,6 +37,7 @@
 INSTALL_LIB = 1
 
 UNITS = dyncall_vector dyncall_api 
+UNITS += dyncall_struct
 
 # @@@ disable dyncall_callf for pcc support temporarly
 ifdef BUILD_TOOL_pcc
Index: dyncall/dyncall/dyncall_api.c
===================================================================
--- dyncall/dyncall/dyncall_api.c	(révision 813)
+++ dyncall/dyncall/dyncall_api.c	(copie de travail)
@@ -85,6 +85,13 @@
   vm->mVTpointer->argPointer(vm,x); 
 }
 
+void dcArgStruct(DCCallVM* vm, DCstruct* s, DCpointer x) 
+{ 
+	printf("vm->mVTpointer->argStruct = %p\n", vm->mVTpointer->argStruct);
+  vm->mVTpointer->argStruct(vm, s, x); 
+}
+
+
 void dcCallVoid(DCCallVM* vm, DCpointer funcptr) 
 {        
   vm->mVTpointer->callVoid(vm, funcptr); 
@@ -135,6 +142,11 @@
   return vm->mVTpointer->callPointer(vm, funcptr); 
 }
 
+void dcCallStruct(DCCallVM* vm, DCpointer funcptr, DCstruct* s, DCpointer x) 
+{ 
+  vm->mVTpointer->callStruct(vm, funcptr, s, x); 
+}
+
 DCint dcGetError(DCCallVM *vm)
 {
   return vm->mError;
Index: dyncall/dyncall/dyncall_callvm_x64.c
===================================================================
--- dyncall/dyncall/dyncall_callvm_x64.c	(révision 813)
+++ dyncall/dyncall/dyncall_callvm_x64.c	(copie de travail)
@@ -23,8 +23,8 @@
 
 #include "dyncall_callvm_x64.h"
 #include "dyncall_alloc.h"
+#include "dyncall_struct.h"
 
-
 static DCCallVM* dc_callvm_new_x64(DCCallVM_vt* vt, DCsize size)
 {
   DCCallVM_x64* self = (DCCallVM_x64*)dcAllocMem(sizeof(DCCallVM_x64)+size);
@@ -148,7 +148,18 @@
     dcVecAppend(&self->mVecHead, &x, sizeof(DCpointer));
 }
 
+static void dc_callvm_argStruct_x64(DCCallVM* in_self, DCstruct* s, DCpointer x)
+{
+  DCCallVM_x64* self = (DCCallVM_x64*)in_self;
+  dcVecAppend(&self->mVecHead, x, s->size);
+  //printf("dc_callvm_argStruct_x64 size = %d\n", (int)s->size);
+  if (s->size <= 64)
+  	  dcArgStructUnroll(in_self, s, x);
+  //else
+  //	  dcVecAppend(&self->mVecHead, &x, sizeof(DCpointer));
+}
 
+
 /* Call. */
 void dc_callvm_call_x64(DCCallVM* in_self, DCpointer target)
 {
@@ -183,6 +194,7 @@
 , &dc_callvm_argFloat_x64
 , &dc_callvm_argDouble_x64
 , &dc_callvm_argPointer_x64
+, &dc_callvm_argStruct_x64
 , (DCvoidvmfunc*)       &dc_callvm_call_x64
 , (DCboolvmfunc*)       &dc_callvm_call_x64
 , (DCcharvmfunc*)       &dc_callvm_call_x64
@@ -193,6 +205,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_x64
 , (DCdoublevmfunc*)     &dc_callvm_call_x64
 , (DCpointervmfunc*)    &dc_callvm_call_x64
+, NULL // argStruct
 };
 
 
Index: dyncall/dyncall/dyncall_callvm_arm32_arm.c
===================================================================
--- dyncall/dyncall/dyncall_callvm_arm32_arm.c	(révision 813)
+++ dyncall/dyncall/dyncall_callvm_arm32_arm.c	(copie de travail)
@@ -163,6 +163,7 @@
 , &dc_callvm_argFloat_arm32_arm
 , &dc_callvm_argDouble_arm32_arm
 , &dc_callvm_argPointer_arm32_arm
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_arm32_arm
 , (DCboolvmfunc*)       &dc_callvm_call_arm32_arm
 , (DCcharvmfunc*)       &dc_callvm_call_arm32_arm
@@ -173,6 +174,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_arm32_arm
 , (DCdoublevmfunc*)     &dc_callvm_call_arm32_arm
 , (DCpointervmfunc*)    &dc_callvm_call_arm32_arm
+, NULL // callStruct
 };
 
 
@@ -190,6 +192,7 @@
 , &dc_callvm_argFloat_arm32_arm
 , &dc_callvm_argDouble_arm32_arm_eabi
 , &dc_callvm_argPointer_arm32_arm
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_arm32_arm
 , (DCboolvmfunc*)       &dc_callvm_call_arm32_arm
 , (DCcharvmfunc*)       &dc_callvm_call_arm32_arm
@@ -200,6 +203,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_arm32_arm
 , (DCdoublevmfunc*)     &dc_callvm_call_arm32_arm
 , (DCpointervmfunc*)    &dc_callvm_call_arm32_arm
+, NULL // argStruct
 };
 
 
Index: dyncall/dyncall/dyncall_callvm.h
===================================================================
--- dyncall/dyncall/dyncall_callvm.h	(révision 813)
+++ dyncall/dyncall/dyncall_callvm.h	(copie de travail)
@@ -49,6 +49,7 @@
   void         (*argFloat)       (DCCallVM* vm,DCfloat         f);
   void         (*argDouble)      (DCCallVM* vm,DCdouble        d);
   void         (*argPointer)     (DCCallVM* vm,DCpointer       p);
+  void         (*argStruct)      (DCCallVM* vm,DCstruct* s, DCpointer p);
   void         (*callVoid)       (DCCallVM* vm,DCpointer funcptr);
   DCbool       (*callBool)       (DCCallVM* vm,DCpointer funcptr);
   DCchar       (*callChar)       (DCCallVM* vm,DCpointer funcptr);
@@ -59,6 +60,7 @@
   DCfloat      (*callFloat)      (DCCallVM* vm,DCpointer funcptr);
   DCdouble     (*callDouble)     (DCCallVM* vm,DCpointer funcptr);
   DCpointer    (*callPointer)    (DCCallVM* vm,DCpointer funcptr);
+  void         (*callStruct)     (DCCallVM* vm,DCpointer funcptr,DCstruct* s, DCpointer returnValue);
 };
 
 typedef DCvoid       (DCvoidvmfunc)      (DCCallVM* vm,DCpointer funcptr); 
Index: dyncall/dyncall/dyncall_callvm_ppc32.c
===================================================================
--- dyncall/dyncall/dyncall_callvm_ppc32.c	(révision 813)
+++ dyncall/dyncall/dyncall_callvm_ppc32.c	(copie de travail)
@@ -302,6 +302,7 @@
 , &dc_callvm_argFloat_ppc32_darwin
 , &dc_callvm_argDouble_ppc32_darwin
 , &dc_callvm_argPointer_ppc32
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_ppc32_darwin
 , (DCboolvmfunc*)       &dc_callvm_call_ppc32_darwin
 , (DCcharvmfunc*)       &dc_callvm_call_ppc32_darwin
@@ -312,6 +313,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_ppc32_darwin
 , (DCdoublevmfunc*)     &dc_callvm_call_ppc32_darwin
 , (DCpointervmfunc*)    &dc_callvm_call_ppc32_darwin
+, NULL // argStruct
 };
 
 DCCallVM_vt gVT_ppc32_sysv =
@@ -328,6 +330,7 @@
 , &dc_callvm_argFloat_ppc32_sysv
 , &dc_callvm_argDouble_ppc32_sysv
 , &dc_callvm_argPointer_ppc32
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_ppc32_sysv
 , (DCboolvmfunc*)       &dc_callvm_call_ppc32_sysv
 , (DCcharvmfunc*)       &dc_callvm_call_ppc32_sysv
@@ -338,6 +341,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_ppc32_sysv
 , (DCdoublevmfunc*)     &dc_callvm_call_ppc32_sysv
 , (DCpointervmfunc*)    &dc_callvm_call_ppc32_sysv
+, NULL // argStruct
 };
 
 void dc_callvm_mode_ppc32(DCCallVM* in_self, DCint mode)
Index: dyncall/dyncall/dyncall_callvm_mips_n32.c
===================================================================
--- dyncall/dyncall/dyncall_callvm_mips_n32.c	(révision 813)
+++ dyncall/dyncall/dyncall_callvm_mips_n32.c	(copie de travail)
@@ -190,6 +190,7 @@
 , &dc_callvm_argFloat_mips_n32
 , &dc_callvm_argDouble_mips_n32
 , &dc_callvm_argPointer_mips_n32
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_mips_n32
 , (DCboolvmfunc*)       &dc_callvm_call_mips_n32
 , (DCcharvmfunc*)       &dc_callvm_call_mips_n32
@@ -200,6 +201,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_mips_n32
 , (DCdoublevmfunc*)     &dc_callvm_call_mips_n32
 , (DCpointervmfunc*)    &dc_callvm_call_mips_n32
+, NULL // argStruct
 };
 
 DCCallVM_vt gVT_mips_n32_ellipsis =
@@ -216,6 +218,7 @@
 , &dc_callvm_argFloat_mips_n32_ellipsis
 , &dc_callvm_argDouble_mips_n32_ellipsis
 , &dc_callvm_argPointer_mips_n32
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_mips_n32
 , (DCboolvmfunc*)       &dc_callvm_call_mips_n32
 , (DCcharvmfunc*)       &dc_callvm_call_mips_n32
@@ -226,6 +229,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_mips_n32
 , (DCdoublevmfunc*)     &dc_callvm_call_mips_n32
 , (DCpointervmfunc*)    &dc_callvm_call_mips_n32
+, NULL // argStruct
 };
 
 static void dc_callvm_mode_mips_n32(DCCallVM* self,DCint mode)
Index: dyncall/dyncall/dyncall_callvm_mips_o32.c
===================================================================
--- dyncall/dyncall/dyncall_callvm_mips_o32.c	(révision 813)
+++ dyncall/dyncall/dyncall_callvm_mips_o32.c	(copie de travail)
@@ -199,6 +199,7 @@
 , &dc_callvm_argFloat_mips_o32
 , &dc_callvm_argDouble_mips_o32
 , &dc_callvm_argPointer_mips_o32
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_mips_o32
 , (DCboolvmfunc*)       &dc_callvm_call_mips_o32
 , (DCcharvmfunc*)       &dc_callvm_call_mips_o32
@@ -209,6 +210,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_mips_o32
 , (DCdoublevmfunc*)     &dc_callvm_call_mips_o32
 , (DCpointervmfunc*)    &dc_callvm_call_mips_o32
+, NULL // argStruct
 };
 
 DCCallVM* dcNewCallVM_mips_o32(DCsize size) 
Index: dyncall/dyncall/dyncall_signature.h
===================================================================
--- dyncall/dyncall/dyncall_signature.h	(révision 813)
+++ dyncall/dyncall/dyncall_signature.h	(copie de travail)
@@ -51,7 +51,9 @@
 #define DC_SIGCHAR_DOUBLE       'd'
 #define DC_SIGCHAR_POINTER      'p'
 #define DC_SIGCHAR_STRING       'Z'
-#define DC_SIGCHAR_ENDARG       ')'
+#define DC_SIGCHAR_STRUCT       'T'
+//#define DC_SIGCHAR_ALIGN        '0' // byte value to which '0' (zero digit) will be substracted to get the alignment
+#define DC_SIGCHAR_ENDARG       ')' // also works for end struct
 
 /* callback signatures */
 
Index: dyncall/dyncall/dyncall_callvm_x86.c
===================================================================
--- dyncall/dyncall/dyncall_callvm_x86.c	(révision 813)
+++ dyncall/dyncall/dyncall_callvm_x86.c	(copie de travail)
@@ -210,6 +210,7 @@
 , &dc_callvm_argFloat_x86
 , &dc_callvm_argDouble_x86
 , &dc_callvm_argPointer_x86
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_x86_cdecl
 , (DCboolvmfunc*)       &dc_callvm_call_x86_cdecl
 , (DCcharvmfunc*)       &dc_callvm_call_x86_cdecl
@@ -220,6 +221,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_x86_cdecl
 , (DCdoublevmfunc*)     &dc_callvm_call_x86_cdecl
 , (DCpointervmfunc*)    &dc_callvm_call_x86_cdecl
+, NULL // argStruct
 };
 
 DCCallVM* dcNewCallVM_x86_cdecl(DCsize size) 
@@ -255,6 +257,7 @@
 , &dc_callvm_argFloat_x86
 , &dc_callvm_argDouble_x86
 , &dc_callvm_argPointer_x86
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_x86_win32_std
 , (DCboolvmfunc*)       &dc_callvm_call_x86_win32_std
 , (DCcharvmfunc*)       &dc_callvm_call_x86_win32_std
@@ -265,6 +268,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_x86_win32_std
 , (DCdoublevmfunc*)     &dc_callvm_call_x86_win32_std
 , (DCpointervmfunc*)    &dc_callvm_call_x86_win32_std
+, NULL // argStruct
 };
 
 /* win32/std callvm allocator */
@@ -364,6 +368,7 @@
 , &dc_callvm_argFloat_x86
 , &dc_callvm_argDouble_x86
 , &dc_callvm_argPointer_x86_win32_fast_ms
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_x86_win32_fast
 , (DCboolvmfunc*)       &dc_callvm_call_x86_win32_fast
 , (DCcharvmfunc*)       &dc_callvm_call_x86_win32_fast
@@ -374,6 +379,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_x86_win32_fast
 , (DCdoublevmfunc*)     &dc_callvm_call_x86_win32_fast
 , (DCpointervmfunc*)    &dc_callvm_call_x86_win32_fast
+, NULL // argStruct
 };
 
 DCCallVM* dcNewCallVM_x86_win32_fast_ms(DCsize size) 
@@ -460,6 +466,7 @@
 , &dc_callvm_argFloat_x86
 , &dc_callvm_argDouble_x86
 , &dc_callvm_argPointer_x86_win32_fast_gnu
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_x86_win32_fast
 , (DCboolvmfunc*)       &dc_callvm_call_x86_win32_fast
 , (DCcharvmfunc*)       &dc_callvm_call_x86_win32_fast
@@ -470,6 +477,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_x86_win32_fast
 , (DCdoublevmfunc*)     &dc_callvm_call_x86_win32_fast
 , (DCpointervmfunc*)    &dc_callvm_call_x86_win32_fast
+, NULL // argStruct
 };
 
 DCCallVM* dcNewCallVM_x86_win32_fast_gnu(DCsize size) 
@@ -503,6 +511,7 @@
 , &dc_callvm_argFloat_x86
 , &dc_callvm_argDouble_x86
 , &dc_callvm_argPointer_x86
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_x86_win32_this_ms
 , (DCboolvmfunc*)       &dc_callvm_call_x86_win32_this_ms
 , (DCcharvmfunc*)       &dc_callvm_call_x86_win32_this_ms
@@ -513,6 +522,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_x86_win32_this_ms
 , (DCdoublevmfunc*)     &dc_callvm_call_x86_win32_this_ms
 , (DCpointervmfunc*)    &dc_callvm_call_x86_win32_this_ms
+, NULL // argStruct
 };
 
 /* win32/this/ms callvm allocator */
Index: dyncall/dyncall/dyncall.h
===================================================================
--- dyncall/dyncall/dyncall.h	(révision 813)
+++ dyncall/dyncall/dyncall.h	(copie de travail)
@@ -44,6 +44,7 @@
 #endif
 
 typedef struct DCCallVM_    DCCallVM;
+typedef struct DCstruct_    DCstruct;
 
 /* Supported Calling Convention Modes */
 
@@ -93,6 +94,7 @@
 DC_API void       dcArgFloat      (DCCallVM* vm, DCfloat    value);
 DC_API void       dcArgDouble     (DCCallVM* vm, DCdouble   value);
 DC_API void       dcArgPointer    (DCCallVM* vm, DCpointer  value);
+DC_API void       dcArgStruct     (DCCallVM* vm, DCstruct* s, DCpointer  value);
 
 DC_API void       dcCallVoid      (DCCallVM* vm, DCpointer funcptr);
 DC_API DCbool     dcCallBool      (DCCallVM* vm, DCpointer funcptr);
@@ -104,9 +106,25 @@
 DC_API DCfloat    dcCallFloat     (DCCallVM* vm, DCpointer funcptr);
 DC_API DCdouble   dcCallDouble    (DCCallVM* vm, DCpointer funcptr);
 DC_API DCpointer  dcCallPointer   (DCCallVM* vm, DCpointer funcptr);
+DC_API void       dcCallStruct    (DCCallVM* vm, DCpointer funcptr, DCstruct* s, DCpointer returnValue);
 
 DC_API DCint      dcGetError      (DCCallVM* vm);
 
+#define DEFAULT_ALIGNMENT 0
+DC_API DCstruct*  dcNewStruct     (DCsize fieldCount, DCint alignment);
+DC_API void       dcStructField   (DCstruct* s, DCint type, DCint alignment, DCsize arrayLength);
+DC_API void       dcSubStruct     (DCstruct* s, DCsize fieldCount, DCint alignment, DCsize arrayLength);  	
+// Each dcNewStruct or dcSubStruct call must be paired with a dcCloseStruct
+DC_API void       dcCloseStruct   (DCstruct* s);  	
+DC_API DCsize     dcStructSize    (DCstruct* s);  	
+DC_API DCsize     dcStructAlignment(DCstruct* s);  	
+DC_API void       dcFreeStruct    (DCstruct* s);
+
+DC_API DCstruct*  dcDefineStruct  (const char* signature);
+
+// Internal: move to some header (dyncall_structs.h for instance)
+void dcArgStructUnroll(DCCallVM* vm, DCstruct* s, DCpointer  value);
+
 #ifdef __cplusplus
 }
 #endif
Index: dyncall/dyncall/dyncall_call_x64_masm.asm
===================================================================
--- dyncall/dyncall/dyncall_call_x64_masm.asm	(révision 813)
+++ dyncall/dyncall/dyncall_call_x64_masm.asm	(copie de travail)
@@ -49,8 +49,8 @@
 
 	sub			rsp, rcx					; Setup stack frame by subtracting the size of the arguments.
 
-	mov			rax, rcx					; Align stack.
-	add			rax, 8
+	mov         rax, rsp                    ; Align stack.
+
 	and			rax, 15
 	sub			rsp, rax
 
Index: dyncall/dynload/dynload_darwin.c
===================================================================
--- dyncall/dynload/dynload_darwin.c	(révision 813)
+++ dyncall/dynload/dynload_darwin.c	(copie de travail)
@@ -27,7 +27,10 @@
 
 
 #include "dynload.h"
+//#include "dynload_macros.h"
+//#include "dyncall_macros.h"
 #include "dyncall_alloc.h"
+
 #include <dlfcn.h>
 #include <string.h>
 
@@ -63,7 +66,6 @@
         return lib;
 }
 
-
 void* dlFindSymbol(DLLib* libHandle, const char* symbol)
 {
   return dlsym(libHandle && libHandle->handle ? libHandle->handle : RTLD_DEFAULT, symbol);
Index: dyncall/dynload/dynload.h
===================================================================
--- dyncall/dynload/dynload.h	(révision 813)
+++ dyncall/dynload/dynload.h	(copie de travail)
@@ -24,6 +24,9 @@
 #ifndef DYNLOAD_H
 #define DYNLOAD_H
 
+
+#include "dyncall_macros.h"
+#include "dynload_macros.h"
 #include <stddef.h>
 #include <stdlib.h>
 
@@ -31,15 +34,19 @@
 extern "C" {
 #endif
 
+#ifndef DC_API
+#define DC_API
+#endif
+
 /* --- public api ---------------------------------------------------------- */
 
 /* shared library loading and explicit symbol resolving */
 
 typedef struct DLLib_ DLLib;
 
-DLLib* dlLoadLibrary(const char* libpath);
-void   dlFreeLibrary(DLLib* pLib);
-void*  dlFindSymbol(DLLib* pLib, const char* pSymbolName);
+DC_API DLLib* dlLoadLibrary(const char* libpath);
+DC_API void   dlFreeLibrary(DLLib* pLib);
+DC_API void*  dlFindSymbol(DLLib* pLib, const char* pSymbolName);
 
 /* symbol table enumeration */
 
Index: dyncall/dynload/dynload_windows.c
===================================================================
--- dyncall/dynload/dynload_windows.c	(révision 813)
+++ dyncall/dynload/dynload_windows.c	(copie de travail)
@@ -32,7 +32,8 @@
 
 DLLib* dlLoadLibrary(const char* libPath)
 {
-  return (DLLib*) LoadLibraryA(libPath);
+  //return (DLLib*) LoadLibraryA(libPath);
+  return (DLLib*) LoadLibraryExA(libPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
 }
 
 void* dlFindSymbol(DLLib* libHandle, const char* symbol)
Index: dyncall/dynload/dynload_syms.c
===================================================================
--- dyncall/dynload/dynload_syms.c	(révision 813)
+++ dyncall/dynload/dynload_syms.c	(copie de travail)
@@ -17,7 +17,10 @@
 
 */
 
+#include "dynload.h"
+#include "dynload_macros.h"
 #include "dyncall_macros.h"
+#include "dyncall_alloc.h"
 
 #if defined(DC_WINDOWS)
 #  include "dynload_syms_pe.c"
Index: dyncall/dynload/dynload_syms_mach-o.c
===================================================================
--- dyncall/dynload/dynload_syms_mach-o.c	(révision 813)
+++ dyncall/dynload/dynload_syms_mach-o.c	(copie de travail)
@@ -33,9 +33,11 @@
 
 #if defined(DC__Arch_AMD64)
 #define MACH_HEADER_TYPE mach_header_64
+#define SEGMENT_COMMAND segment_command_64
 #define NLIST_TYPE nlist_64
 #else
 #define MACH_HEADER_TYPE mach_header
+#define SEGMENT_COMMAND segment_command
 #define NLIST_TYPE nlist
 #endif
 
@@ -67,8 +69,13 @@
 		const char* name = _dyld_get_image_name(iImage);
 		if (name && !strcmp(name, pLib->libPath))
 		{
-			const struct mach_header* pHeader = _dyld_get_image_header(iImage);
-			const char* pBase = (const char*)pHeader;
+			const struct MACH_HEADER_TYPE* pHeader = _dyld_get_image_header(iImage);
+			const char* pBase = ((const char*)pHeader);
+			if (pHeader->filetype != MH_DYLIB)
+				return NULL;
+			if (pHeader->flags & MH_SPLIT_SEGS)
+				return NULL;
+
 			if (pHeader)
 			{
 				uint32_t iCmd, nCmds = pHeader->ncmds;
@@ -106,7 +113,6 @@
 	dcFreeMem(pSyms);
 }
 
-
 int dlSymsCount(DLSyms* pSyms)
 {
 	if (!pSyms)
@@ -114,7 +120,6 @@
 	return pSyms->symbolCount;
 }
 
-
 static const struct NLIST_TYPE* get_nlist(DLSyms* pSyms, int index)
 {
 	const struct NLIST_TYPE* nl;
Index: dyncall/dynload/dynload.c
===================================================================
--- dyncall/dynload/dynload.c	(révision 813)
+++ dyncall/dynload/dynload.c	(copie de travail)
@@ -18,11 +18,14 @@
 */
 
 #include "dynload.h"
+//#include "dynload_macros.h"
 #include "dyncall_macros.h"
+//#include "dyncall_alloc.h"
+
 #if defined(DC_WINDOWS)
 #  include "dynload_windows.c"
 #elif defined(DC_UNIX)
-#  if defined (DC__OS_Darwin)
+#  if defined(DC__OS_Darwin)
 #    include "dynload_darwin.c"
 #  else
 #    include "dynload_unix.c"
Index: dyncall/dynload/dynload_syms_elf.c
===================================================================
--- dyncall/dynload/dynload_syms_elf.c	(révision 813)
+++ dyncall/dynload/dynload_syms_elf.c	(copie de travail)
@@ -20,6 +20,7 @@
 
 #if defined(DC__OS_Linux) && !defined(_GNU_SOURCE)
 #define _GNU_SOURCE
+#define __USE_GNU
 #endif
 
 /*
@@ -30,12 +31,15 @@
 
 #include "dynload.h"
 #include "dynload_macros.h"
+#include "dynload_unix.h"
 #if defined(DC__OS_OpenBSD)
 #	include <elf_abi.h>
 #else
 #	include <elf.h>
 #endif
-#include "dyncall_alloc.h"
+#if defined(DC__OS_SunOS)
+#   include <link.h>
+#endif
 #include <assert.h>
 #include <dlfcn.h>
 #include <stdio.h>
@@ -45,6 +49,7 @@
 #ifdef DL__BinaryFormat_elf64
 typedef Elf64_Ehdr   Elf_Ehdr;
 typedef Elf64_Phdr   Elf_Phdr;
+typedef Elf64_Shdr   Elf_Shdr;
 typedef Elf64_Sym    Elf_Sym;
 typedef Elf64_Dyn    Elf_Dyn;
 typedef Elf64_Sxword Elf_tag;
@@ -52,70 +57,22 @@
 #else
 typedef Elf32_Ehdr   Elf_Ehdr;
 typedef Elf32_Phdr   Elf_Phdr;
+typedef Elf32_Shdr   Elf_Shdr;
 typedef Elf32_Sym    Elf_Sym;
 typedef Elf32_Dyn    Elf_Dyn;
 typedef Elf32_Sword  Elf_tag;
 typedef Elf32_Addr   Elf_Addr;
 #endif
 
-
-struct DLLib_
-{
-  Elf_Ehdr* pElf_Ehdr;
-};
-
-
-typedef struct 
-{
-  uint32_t nbucket;        
-  uint32_t nchain;         /* the total size of symbols */
-
-  /* 
-
-   it follows two arrays ...
-   
-   uint32_t bucket[nbucket-1] 
-   uint32_t chain[nchain-1]      
-
-  */
-
-} Elf_Hash;
-
-
-typedef struct {
-  uint32_t nbuckets; /* the number of buckets */
-  uint32_t symndx; /* The dynamic symbol table has dynsymcount symbols. symndx is the index of
-  the first symbol in the dynamic symbol table that is to be accessible via the hash table.
-  This implies that there are (dynsymcount - index) symbols accessible  via the hash table.
-  */
-  uint32_t maskwords; /* the number of ELFCLASS sized words in the Bloom filter portion of the hash table section.
-  This value must be non-zero, and must be a power of 2 as explained below.
-
-  Note that a value of 0 could be interpreted to mean that no Bloom filter is present in the hash section.
-  However, the GNU linkers do not do this -- the GNU hash section always includes at least 1 mask word.
-  */
-  uint32_t shift2; /* A shift count used by the Bloom filter. */
-
-  /* Following ... 
-
-  Elf_Addr bloom[maskwords];  // bloom filter to rapidly reject attempts to look up symbols.
-  uint32_t buckets[nbuckets]; // an Array of nbucket 32-bit hash values.
-  uint32_t chain[dynsymcount - symndx];
-  
-  */
-} Elf_GNU_Hash;
-
-
 struct DLSyms_
 {
   const char* pStrTab;
-  Elf_Hash*   pHash;
   Elf_Sym*    pSymTab;
-  Elf_GNU_Hash* pGNUHash;
-  uint32_t*     pGNUHashChain;
+  size_t strTabSize;
+  size_t nSymbols;
+  DLLib*      pLib;
 };
 
-
 DLSyms* dlSymsInit(DLLib* pLib)
 {
   DLSyms* pSyms;
@@ -123,11 +80,8 @@
     return NULL;
    
   pSyms = (DLSyms*)dcAllocMem(sizeof(DLSyms));
-  pSyms->pStrTab  = 0;
-  pSyms->pSymTab  = 0;
-  pSyms->pHash    = 0;
-  pSyms->pGNUHash = 0;
-  pSyms->pGNUHashChain = 0;
+  memset(pSyms, 0, sizeof(DLSyms));
+  pSyms->pLib     = pLib;
 
   Elf_Ehdr* pH   = pLib->pElf_Ehdr;
 #ifdef DL__BinaryFormat_elf32
@@ -135,285 +89,74 @@
 #else
   assert( pH->e_ident[EI_CLASS] == ELFCLASS64 );
 #endif
-
+	
   assert(pH->e_phoff > 0);
   assert(pH->e_shoff > 0);
+  
   unsigned char* pMem = (unsigned char*) pH;
   Elf_Phdr* pP = (Elf_Phdr*) ( pMem + pH->e_phoff );
   
   int i; 
-
-  /* traverse run-time program headers */
-  
-  for (i=0;i<pH->e_phnum;++i)
+  /* traverse section headers */
+  Elf_Shdr* pS = (Elf_Shdr*) ( pMem + pH->e_shoff );
+  /* skip section 0 which is always zero due to the Elf standard. */
+  for (i = 1; i < pH->e_shnum; i++) 
   {
-    Elf_Phdr* p = &pP[i];
-    switch( p->p_type )
+    Elf_Shdr* pSection = &pS[i];
+    void* pSectionContent = ((char*)pMem) + pSection->sh_offset;
+    switch( pSection->sh_type )
     {
-      case PT_DYNAMIC:
-        {
-          Elf_Dyn* pDyn = (Elf_Dyn*) ( pMem + p->p_vaddr );
-          int sSymEnt = -1;
-          int sStrSz = -1;
-          for(;;) {
-            Elf_tag dt = pDyn->d_tag;
-            if (dt == DT_NULL) break;
-            switch(dt)
-            {
-              case DT_STRTAB:   pSyms->pStrTab  = (const char*)   pDyn->d_un.d_ptr; break;
-              case DT_SYMTAB:   pSyms->pSymTab  = (Elf_Sym*)      pDyn->d_un.d_ptr; break;
-              case DT_HASH:     pSyms->pHash    = (Elf_Hash*)     pDyn->d_un.d_ptr; break;
-/* this one was not defined on dyncall.org machine */
-#if defined DT_GNU_HASH
-              case DT_GNU_HASH: pSyms->pGNUHash = (Elf_GNU_Hash*) pDyn->d_un.d_ptr; break;
-#endif
-            }
-            pDyn++;
-          }
-
+      case SHT_DYNSYM:
+        if (!pSyms->pSymTab) {
+          pSyms->pSymTab  = (Elf_Sym*)pSectionContent;
+          pSyms->nSymbols = pSection->sh_size / pSection->sh_entsize;
         }
         break;
+      case SHT_STRTAB:
+        // Do not trust pH->e_shstrndx !
+        if (!pSyms->pStrTab) {
+          pSyms->pStrTab  = (const char*)pSectionContent;
+          pSyms->strTabSize = pSection->sh_size;
+        }
+        break;
     }
-  }
-  if (pSyms->pGNUHash) {
-    Elf_GNU_Hash* p = pSyms->pGNUHash;
-    Elf_Addr* pbloom = (Elf_Addr*) ( &p[1] );
-    uint32_t* pbuckets = (uint32_t*) &pbloom[p->maskwords];
-    uint32_t* pchain   = (uint32_t*) &pbuckets[p->nbuckets];
-    pSyms->pGNUHashChain = pchain;
-  }
+    if (pSyms->pSymTab && pSyms->pStrTab)
+      break;
+  }  
   return pSyms;
 }
 
-
 void dlSymsCleanup(DLSyms* pSyms)
 {
   dcFreeMem(pSyms);
 }
 
-
 int dlSymsCount(DLSyms* pSyms)
 {
-  if (!pSyms || !pSyms->pHash)
+  if (!pSyms)
     return 0;
-
-  if (pSyms->pGNUHash) {
-    return pSyms->pHash->nchain - pSyms->pGNUHash->symndx;
-  } else {
-    return pSyms->pHash->nchain;
-  }
+  return pSyms->nSymbols;
 }
 
-
 const char* dlSymsName(DLSyms* pSyms, int index)
 {
-  int export_base;
-  if(!pSyms || !pSyms->pSymTab)
+  if(!pSyms || !pSyms->pSymTab || index < 0 || index >= pSyms->nSymbols)
     return NULL;
-
-  if (pSyms->pGNUHash) {
-    export_base = pSyms->pGNUHash->symndx;
-  } else {
-    export_base = 0;
-  }
-  int str_index = pSyms->pSymTab[ export_base + index ].st_name;
+  
+  int str_index = pSyms->pSymTab[ index ].st_name;
+  if (str_index < 0 || str_index >= pSyms->strTabSize)
+    return NULL;
   return &pSyms->pStrTab[str_index];
 }
 
-
 void* dlSymsValue(DLSyms* pSyms, int index)
 {
-  int export_base;
-  if(!pSyms || !pSyms->pSymTab)
+  if(!pSyms || !pSyms->pSymTab || index < 0 || index >= pSyms->nSymbols)
     return NULL;
 
-  if (pSyms->pGNUHash) {
-    export_base = pSyms->pGNUHash->symndx;
-  } else {
-    export_base = 0;
-  }
-  return (void*) pSyms->pSymTab[ export_base + index ].st_value;
+  return dlFindSymbol(pSyms->pLib, dlSymsName(pSyms, index));
 }
 
-
-#if 0
-
-/*
- * the "gnu hash" / DJB hash function
- */
-
-uint32_t
-dl_new_hash(const char* s)
-{
-  uint32_t h = 5381;
-  for (unsigned char c = *s; c != '\0' ; c = *++s)
-    h = h * 33 + c;
-  return h;
-}
-
-
-/* GNU binutils implementation: */
-static uint_fast32_t
-dl_new_hash(const char* s)
-{
-  uint_fast32_t h = 5381;
-  for (unsigned char c = *s; c != '\0' ; c = *++s)
-    h = h * 33 + c;
-  return h & 0xffffffff;
-}
-#endif
-
-
-#if 0
-/*
- * the hash function 
- */
-unsigned long
-elf_hash(const unsigned char* name)
-{
-  unsigned long h = 0, g;
-  while(*name) {
-    h = (h << 4) + *name++;
-    if (g = h & 0xf0000000)
-      h ^= g >> 24;
-    h &= ~g;
-  }
-  return h;
-}
-#endif
-
-
-#if 0
-void dlInitSyms_elf64(DLSyms* pResolver, DLLib* pLib)
-{
-  pResolver->elf64 = 1;
-  Elf64_Ehdr* pH   = pLib->u.pElf64_Ehdr;
-  assert(pH->e_phoff > 0);
-  assert(pH->e_shoff > 0);
-  DLubyte* pMem = (DLubyte*) pH;
-  Elf64_Phdr* pP = (Elf64_Phdr*) ( pMem + pH->e_phoff );
-  
-  int i; 
-
-  /* traverse run-time program headers */
-  
-  int pi_dynamic = -1;
-  for (i=0;i<pH->e_phnum;++i)
-  {
-    Elf64_Phdr* p = &pP[i];
-    switch( p->p_type )
-    {
-      case PT_DYNAMIC:
-        {
-          pi_dynamic = i;
-          Elf64_Dyn* pDyn = (Elf64_Dyn*) ( pMem + p->p_vaddr );
-          int sSymEnt = -1;
-          int sStrSz = -1;
-          for(;;) {
-            Elf64_Sxword dt = pDyn->d_tag;
-            if (dt == DT_NULL) break;
-            switch(dt)
-            {
-              case DT_STRTAB: pResolver->pStrTab = (const char*) pDyn->d_un.d_ptr; break;
-              case DT_SYMTAB: pResolver->u.pSymTab64 = (Elf64_Sym*)  pDyn->d_un.d_ptr; break;
-              case DT_HASH:   pResolver->pHash =   (Elf_Hash*) pDyn->d_un.d_ptr; break;
-              // case DT_SYMENT: sSymEnt = (int) pDyn->d_un.d_val; break;
-              // case DT_STRSZ:  sStrSz  = (int) pDyn->d_un.d_val; break;
-              // case DT_SYMBOLIC: printf("symbolic!\n"); break;
-              // case DT_STRTAB: pS_StrTab = (Elf64_Shdr*) pDyn->d_un.d_ptr; break;
-              // case DT_SYMTAB: pS_SymTab = (Elf64_Shdr*) pDyn->d_un.d_ptr; break;
-            }
-            pDyn++;
-          }
-#if 0
-          /* traversing the symbol table */
-          int j;
-          /* by convention, the first symbol table references an undefined symbol */
-          // pStrTab = &pS[ pH->e_shstrndx ];
-          for(j=1; j < pHash->nchain ;++j) {
-
-            // int name = pS_StrTab->sh_name;
-            int sti = pSymTab[j].st_name;
-
-            printf("%s\n", &pStrTab[sti] );
-
-          }
-#endif
-
-        }
-        break;
-    }
-  }
-
-#if 0
-  /* traverse section headers */
-  Elf64_Shdr* pS = (Elf64_Shdr*) ( pMem + pH->e_shoff );  
-  int dynsym = -1;
-  /* skip section 0 which is always zero due to the Elf standard. */
-  for (i=1;i<pH->e_shnum;++i) 
-  {
-    Elf64_Shdr* p= &pS[i];
-    
-    switch( p->sh_type )
-    {
-      case SHT_DYNSYM:
-        dynsym = i;
-        break;
-    }
-  }
-#endif
-
-
-  // return 0;
-}
-
-
-void dlInitSyms_elf32(DLLib* pLib)
-{
-  DLSyms* pResolver = (DLSyms*)dcAllocMem(sizeof(DLSyms));
-  pResolver->elf64 = 0;
-  Elf32_Ehdr* pH   = pLib->u.pElf32_Ehdr;
-  assert(pH->e_phoff > 0);
-  assert(pH->e_shoff > 0);
-  DLubyte* pMem = (DLubyte*) pH;
-  Elf32_Phdr* pP = (Elf32_Phdr*) ( pMem + pH->e_phoff );
-  
-  int i; 
-
-  /* traverse run-time program headers */
-  
-  int pi_dynamic = -1;
-  for (i=0;i<pH->e_phnum;++i)
-  {
-    Elf32_Phdr* p = &pP[i];
-    switch( p->p_type )
-    {
-      case PT_DYNAMIC:
-        {
-          pi_dynamic = i;
-          Elf32_Dyn* pDyn = (Elf32_Dyn*) ( pMem + p->p_vaddr );
-          int sSymEnt = -1;
-          int sStrSz = -1;
-          for(;;) {
-            Elf32_Sword dt = pDyn->d_tag;
-            if (dt == DT_NULL) break;
-            switch(dt)
-            {
-              case DT_STRTAB: pResolver->pStrTab = (const char*) pDyn->d_un.d_ptr; break;
-              case DT_SYMTAB: pResolver->u.pSymTab32 = (Elf32_Sym*)  pDyn->d_un.d_ptr; break;
-              case DT_HASH:   pResolver->pHash =   (Elf_Hash*) pDyn->d_un.d_ptr; break;
-            }
-            pDyn++;
-          }
-
-        }
-        break;
-    }
-  }
-}
-#endif
-
-
 const char* dlSymsNameFromValue(DLSyms* pSyms, void* value)
 {
   Dl_info info;
Index: dyncall/dynload/dynload_unix.c
===================================================================
--- dyncall/dynload/dynload_unix.c	(révision 813)
+++ dyncall/dynload/dynload_unix.c	(copie de travail)
@@ -25,23 +25,56 @@
 
 */
 
+#if defined(DC__OS_Linux) && !defined(_GNU_SOURCE)
+#define _GNU_SOURCE
+#define __USE_GNU
+#endif
 
 #include "dynload.h"
+#include "dynload_unix.h"
 
 #include <dlfcn.h>
+#include <sys/mman.h>
+#include <stdio.h>
+#include <sys/stat.h>
+#include <sys/fcntl.h>
 
 DLLib* dlLoadLibrary(const char* libPath)
 {
-  return (DLLib*) dlopen(libPath,RTLD_NOW);
+  DLLib* pLib;
+  struct stat st;
+  void* pHandle = dlopen(libPath, RTLD_LAZY | RTLD_GLOBAL);
+  if (!pHandle)
+    return NULL;
+  
+  pLib = (DLLib*)malloc(sizeof(DLLib));
+  pLib->libHandle = pHandle;
+  	  
+  pLib->file = open(libPath, O_RDONLY);
+  stat(libPath, &st);
+  pLib->fileSize = st.st_size;
+  pLib->pElf_Ehdr = mmap(NULL, pLib->fileSize, PROT_READ, MAP_SHARED, pLib->file, 0);
+  /* 
+  Old hack on Linux :
+  typedef struct DLOpenHandle_
+  {
+    void* pElf_Ehdr;
+  } DLOpenHandle;
+  pLib->pElf_Ehdr = ((DLOpenHandle*)pHandle)->pElf_Ehdr;
+  */
+  return pLib;
 }
 
-void* dlFindSymbol(DLLib* libHandle, const char* symbol)
+void* dlFindSymbol(DLLib* pLib, const char* symbol)
 {
-  return dlsym( (void*) libHandle, symbol);
+  return dlsym(pLib ? pLib->libHandle : RTLD_DEFAULT, symbol);
 }
 
-void  dlFreeLibrary(DLLib* libHandle)
+void  dlFreeLibrary(DLLib* pLib)
 {
-  dlclose( (void*) libHandle);
+  munmap(pLib->pElf_Ehdr, pLib->fileSize);
+  close(pLib->file);
+  dlclose(pLib->libHandle);
+  free(pLib);
 }
 
Index: dyncall/buildsys/gmake/prolog.gmake
===================================================================
--- dyncall/buildsys/gmake/prolog.gmake	(révision 813)
+++ dyncall/buildsys/gmake/prolog.gmake	(copie de travail)
@@ -28,6 +28,7 @@
 
 # config settings
 
+#$(if $(wildcard "${TOP}/ConfigVars"),$(error hmm),$(error File 'ConfigVars' not found at top directory. Run 'configure' - or, if you use CMake, run 'make -f Makefile' please.))
 ifeq ($(wildcard $(TOP)/ConfigVars),)
 $(error File 'ConfigVars' not found at top directory. Run 'configure' - or, if you use CMake, run 'make -f Makefile' please.)
 else
